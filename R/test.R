##' Draw a circle
##' 
##' @param xvec x-coordinates
##' @param yvec y-coordinates
##' @param rvec radii
##' @param vertex the number of vertices of the circle
##' @param border color of border
##' @param col color to render in circle
##' @param add Whether the circles are added to another plot.
##' @examples
##' x=y=1:5
##' r=5:1/5
##' circle(x,y,r,add=FALSE,asp=1)
##'
circle = function(xvec,yvec,rvec,vertex=100,border=1,col=NULL,add=TRUE,...){
    # This function is used to compute the locations of the circle border 
    # and draw multiple circles.
    # Borrowing the code from plotrix::draw.circle
    n=length(xvec)
    stopifnot(length(yvec)==n && n==length(rvec))
    if (length(border) < n)  border = rep(border, length.out = n)
    if (!is.null(col) && length(col) < n) col = rep(col, length.out = n)
    # xylim = par("usr")
    # plotdim = par("pin")
    # ymult = (xylim[4] - xylim[3])/(xylim[2] - xylim[1]) * plotdim[1]/plotdim[2]
    angle.inc = 2 * pi / vertex
    angles = seq(0, 2 * pi - angle.inc, by = angle.inc)
    if (!add) plot(c(min(x-r),max(x+r)),c(min(y-r),max(y+r)),type='n',xlab='x',ylab='y',...)
    for (i in 1:n){
        xv <- cos(angles) * rvec[i] + xvec[i]
        yv <- sin(angles) * rvec[i] + yvec[i]
        polygon(xv, yv, border = border[i], col = col)
    }
}

##' Find the nearest k neighbors
##' 
##' @param dismtrx The matrix of distance, typically generated by dist().
##' @param k The number of nearest neighbors that are chosen.
##' @return A data frame of indice. For each row, the i th cell is its i th nearest neighbor.
##' @exportPattern "^[^\\.]"
##' @export
##' @examples
##' data(usCapitals)
##' capital_dist=as.matrix(dist(usCapitals[,4:5]))
##' capital_neighbor_3=nnbr(capital_dist)
##' capital_neighbor_5=nnbr(capital_dist, 5)
##' 
nnbr = function(distmtrx,k=3){
    stopifnot(k < nrow(distmtrx))
    res=apply(distmtrx,1,function(xv){order(xv)[1:(k+1)]})
    res=t(res)[,2:(k+1)]
    if (k>1) colnames(res)=paste('N',1:k,sep='')
    return(res)
}

##' Find all the neighbors for the polygons by checking duplicated coordinates.
##' 
##' @param region Region names.
##' @param x X-coordinates.
##' @param y Y-coordinates.
##' @return "nbr" and "centroid". nbr is a list of neighbors, while centroid is the coordinates of polygon centroids.
##' @examples
##' data(usCapitals)
##' state_nbrs=nbrlist(state$abbr,state$x,state$y)
##' 
nbrlist = function(region,x,y){
    stopifnot(length(x)==length(region) && length(y)==length(region))
    library(maps)
    digitx = max(min(nchar(as.character(x))),5)
    digity = max(min(nchar(as.character(y))),5)
    dat=data.frame(r=region,x=x,y=y)
    dat$r=as.character(dat$r)
    dat$p=paste(round(dat$x,digitx),round(dat$y,digity))
    dat=dat[!duplicated(dat),]
    censordat=dat[duplicated(dat$p)|duplicated(dat$p,fromLast=TRUE),]
    uniregion=sort(unique(region))
    k=length(uniregion)
    res1=list()
    res2=data.frame(region=uniregion,x=NA,y=NA)
    res2$region=as.character(res2$region)
    for (i in 1:k){
        ins=censordat[censordat$r %in% uniregion[i],]
        out=censordat[! censordat$r %in% uniregion[i],]
        res1[[i]]=unique(out[out$p %in% ins$p,1])
        res2[i,2:3]=centroid.polygon(dat[dat$r==uniregion[i],2:3])
    }
    names(res1)=uniregion
    return(list(nbr=res1,centroid=res2))
}

##' Produce a Dorling Cartogram.
##' 
##' @param name A vector of region names.
##' @param centroidx A vector of x-coordinates of the regions.
##' @param centroidy A vector of y-coordinates of the regions.
##' @param density A vector of the variable of interest. It will be used as the radii of the circles.
##' @param nbr A list of the neighbors of every region. Each element is a vector of all the neighbor names of a region. If nbr=NULL, then it is assumed that no region has any neighbors. If nbr is not NULL, then names should be given to all the elements of the list, for matching the neighbors with the host region name, otherwise the parameter "name" (a character vector) will be used as the element names of nbr. Besides, any values in nbr that are not in "name" will be removed. The length of nbr could be different from the length of "name", but any element in nbr whose name is not in "name" will be removed too.
##' 
dorling = function(name,centroidx,centroidy,density,nbr=NULL,...){
    n=length(name)
    stopifnot(n==length(centroidx), n==length(centroidy), n==length(density))
    
    # identify all the names
    name=as.character(name)
    if (is.null(names(nbr)) && sum(duplindex <- duplicated(name))) {
        name[duplindex]=paste(name[duplindex],name[duplindex],1:sum(duplindex),sep="_")
    }
    
    # clean "nbr"
    if (!is.null(nbr)) {        
        if (is.null(names(nbr))) {
            stopifnot(n==length(nbr))
            names(nbr)=name
        } else {
            nbr=nbr[names(nbr) %in% name]
        }
        if (any(!unlist(nbr) %in% name)) {
            for (i in 1:n){
                nbr[[i]]=nbr[[i]][nbr[[i]] %in% name]
            }
        }
    }

    # Set up the data
    dat=data.frame(name=name,x=centroidx,y=centroidy,density=density,stringsAsFactors=FALSE)
    rownames(dat)=dat$name
    origindist=as.matrix(dist(dat[,2:3]))
    dat$density=dat$density/max(dat$density)*mean(origindist)/5
    
    circleDist=outer(dat$density,dat$density,"+")
    diag(circleDist)=0
    colnames(circleDist)=rownames(circleDist)=rownames(usdist)
    
    crtloc=frc=dat[,3:4]
    crtloc$Latitude=frc$Latitude=dat$centroidy
    crtloc$Longitude=frc$Longitude=dat$centroidx
    crtDist=usdist
    s=0
    err=circleDist-crtDist
    
    while (sum(sapply(err,max,0))>0.1) {
        s=s+1
        if (s%%10==1) print(s)
        plot(Latitude~Longitude,crtloc,type='p',col=2,pch=20)
        circle(crtloc$Longitude,crtloc$Latitude,dat$density)
        text(crtloc$Longitude,crtloc$Latitude,dat$Abbr,cex=0.8)
        Sys.sleep(0.3)
        
        frc$xforce=frc$yforce=frc$xattract=frc$yattract=frc$xrepel=frc$yrepel=0.00000
        idx= circleDist > crtDist
        idx= idx & lower.tri(idx)
        err= circleDist-crtDist
        for (i in which(rowSums(idx)>0)){
            for (j in which(idx[i,1:(i-1)])){
                ratio=(circleDist[i,j]-crtDist[i,j])/2/crtDist[i,j]
                frc$xrepel[i]=frc$xrepel[i]+ratio*(crtloc$Longitude[i]-crtloc$Longitude[j])
                frc$xrepel[j]=frc$xrepel[j]+ratio*(crtloc$Longitude[j]-crtloc$Longitude[i])
                frc$yrepel[i]=frc$yrepel[i]+ratio*(crtloc$Latitude[i]-crtloc$Latitude[j])
                frc$yrepel[j]=frc$yrepel[j]+ratio*(crtloc$Latitude[j]-crtloc$Latitude[i])
            }
        }
        for (i in 1:length(nbrs)){
            for (j in 1:length(nbrs[[i]])){
                crtstate=names(nbrs)[i]
                crtnbr=which(rownames(crtDist)==nbrs[[i]][j])
                distratio=crtDist[crtstate,crtnbr]/circleDist[crtstate,crtnbr]
                if (distratio > 2){
                    ratio=(crtDist[crtstate,crtnbr]-circleDist[crtstate,crtnbr])/(round(s/10)+8)/crtDist[crtstate,crtnbr]
                    frc$xattract[i]=frc$xattract[i]-ratio*(crtloc$Longitude[i]-crtloc$Longitude[crtnbr])
                    frc$xattract[crtnbr]=frc$xattract[crtnbr]-ratio*(crtloc$Longitude[crtnbr]-crtloc$Longitude[i])
                    frc$yattract[i]=frc$yattract[i]-ratio*(crtloc$Latitude[i]-crtloc$Latitude[crtnbr])
                    frc$yattract[crtnbr]=frc$yattract[crtnbr]-ratio*(crtloc$Latitude[crtnbr]-crtloc$Latitude[i])
                }
            }
        }
        frc$xforce=frc$xrepel+frc$xattract
        frc$yforce=frc$yrepel+frc$yattract
        closest=data.frame(cbind(rownames(crtDist),rownames(crtDist)[nnbr(crtDist,k=1)]))
        closest$dist=apply(closest,1,function(xv){crtDist[xv[1],xv[2]]})
        closest$force=sqrt(frc$xforce^2+frc$yforce^2)
        closest$idx=closest$force>closest$dist
        frc$xforce[closest$idx]=frc$xforce[closest$idx]*closest$dist[closest$idx]/closest$force[closest$idx]
        frc$yforce[closest$idx]=frc$yforce[closest$idx]*closest$dist[closest$idx]/closest$force[closest$idx]
        
        crtloc=crtloc+frc[,7:8]
        crtDist=as.matrix(dist(crtloc))
    }
}
